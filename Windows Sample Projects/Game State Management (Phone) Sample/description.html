<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
    <head><link rel="stylesheet" type="text/css" href="description/Combined.css,1:ImageSprite;/Areas/Epx/Themes/Msdn/Content:0,/Areas/Epx/Content/Css:1&amp;amp;hashKey=E7560C71640616C5057FAEACB58DCB00" xmlns="http://www.w3.org/1999/xhtml" />
<link rel="stylesheet" type="text/css" href="description/2f95808e-ca34-4249-88ff-44fabe33cdc0Combined.css,1:LinkList,2:ImageSprite,2:SiteFeedbackLink;/Areas/Epx/Themes/Msdn/Content:0,/Areas/Epx/Themes/Base/Content:1,/Areas/Epx/Content/Css:2&amp;amp;hashKey=EEE39C2D6B93379FDAF50337BE99AF8C" xmlns="http://www.w3.org/1999/xhtml" />

        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Game State Management (Phone) Sample</title>
        <link href="description/Galleries.css" type="text/css" rel="Stylesheet" /><link href="description/Layout.css" type="text/css" rel="Stylesheet" /><link href="description/Brand.css" type="text/css" rel="Stylesheet" />
        <link href="description/iframedescription.css" rel="Stylesheet" type="text/css" />
        <script src="description/offline.js" type="text/javascript"></script>
        <style type="text/css">
            #projectInfo {
                overflow: auto;
            }
            #longDesc {
                clear:both;
                margin: 25px 0 10px 0;
            }

            #SampleIndexList{
                margin-left: 15px;
            }
        </style>
    </head>
<body>
    <div id="offlineDescription">
        <h1>Game State Management (Phone) Sample</h1>
        <br/>
        <div id="projectInfo">
            <div class="section">
                    <div class="itemBarLong tagsContainer">
                        <label for="Technologies">Technologies</label>
                        <div id="Technologies">
                            Windows Phone, XNA Game Studio 4.0, XNA Game Studio
                        </div>
                    </div>
                    <div class="itemBarLong tagsContainer">
                        <label for="Topics">Topics</label>
                        <div id="Topics">
                            Games, State Management
                        </div>
                    </div>
                <div class="itemBarLong">
                    <label for="Platforms">Platforms</label>
                    <div id="Platforms">
                        Phone
                    </div>
                </div>
                <div class="itemBarLong">
                    <label for="Requirements">Requirements</label>
                    <div id="Requirements">
                        
                    </div>
                </div>
                <div class="itemBar">
                    <label for="LastUpdated">Primary Language</label>
                    <div id="LastUpdated">en-US</div>
                </div>
                <div class="itemBar">
                    <label for="LastUpdated">Last Updated</label>
                    <div id="LastUpdated">5/4/2011</div>
                </div>
                <div class="itemBarLong">
                    <label for="License">License</label>
                    <div id="License">
                        <a href="license.rtf">Custom</a></div>
                </div>
                <div class="itemBar">
                    <div class="viewonlinecont">
                        <a data-link="online" href="http://code.msdn.microsoft.com/Game-State-Management-b7869983">View this sample online</a>
                    </div>
                </div>
            </div>
        </div>
        
                   
<script type="text/javascript">
    function initializePage() {
        var otherTabClass = 'otherTab';
        var hiddenPreClass = 'hidden';

        var htmlDecode = function(encodedData) {
            var decodedData = "";
            if (encodedData) {
                var div = document.createElement('div');
                div.innerHTML = encodedData;
                decodedData = div.firstChild.nodeValue.replace( /\\r\\n/ig , '\r\n');
            }
            return decodedData;
        };
                
        Galleries.iterateElem(Galleries.findElem(null, 'div', 'scriptcode'), function (index, scriptBlock) {
            var titleElem = Galleries.findElem(scriptBlock, 'div', 'title')[0];
            var labelElems = Galleries.findElem(titleElem, 'span');
            if (labelElems.length == 0) {
                labelElems = titleElem;
            }
            var languageSpans = Galleries.findElem(scriptBlock, 'span', 'hidden');
            var pres = Galleries.findElem(scriptBlock, 'pre');
            if (languageSpans.length > 0 && pres.length > 1) {
                Galleries.iterateElem(labelElems, function(index, elem) {
                    var codePre = pres[index];
                    var labelSpan = elem;
                    var languageSpan = languageSpans[index];
                            
                    elem.code = codePre.innerHTML.replace( /(\r(\n)?)|((\r)?\n)/ig , '\\r\\n');
                            
                    codePre.className = codePre.className.replace(hiddenPreClass, '');
                            
                    languageSpan.parentNode.removeChild(languageSpan);
                });

                pres = Galleries.findElem(scriptBlock, 'pre');
                Galleries.iterateElem(labelElems, function(index, elem) {
                    var codePre = pres[index];
                    var labelSpan = elem;
                    if (index == 0) {
                        scriptBlock.activeTab = 0;
                    }
                    else {
                        labelSpan.className += otherTabClass;
                        codePre.className += hiddenPreClass;
                    }
                    Galleries.attachEventHandler(labelSpan, 'click', function(e) {
                        var activeTab = scriptBlock.activeTab;
                        labelElems[activeTab].className += otherTabClass;
                        pres[activeTab].className += hiddenPreClass;

                        codePre.className = codePre.className.replace(hiddenPreClass, '');
                        labelSpan.className = labelSpan.className.replace(otherTabClass, '');
                        scriptBlock.activeTab = index;
                    });
                });

                var preview = Galleries.findElem(scriptBlock, 'div', 'preview');
                if (preview.length == 0) {
                    preview.push(pres[pres.length - 1]);
                }
                Galleries.iterateElem(preview, function(index, elem) {
                    elem.parentNode.removeChild(elem);
                });

                if (window.clipboardData && clipboardData.setData) {
                    var copyLink = document.createElement('a');
                    copyLink.href = 'javascript:void(0);';
                    copyLink.className = 'copyCode';
                    copyLink.innerHTML = 'Copy Code';
                    Galleries.attachEventHandler(copyLink, 'click', function (e) {
                        clipboardData.setData("Text", htmlDecode(labelElems[scriptBlock.activeTab].code));
                        return false;
                    });
                    scriptBlock.insertBefore(copyLink, scriptBlock.childNodes[0]);
                }
            }
        });
    }

    Galleries.onWindowLoad(function(){
        initializePage();
    });

</script>
<div id="longDesc">
    
<p id="mainBody"><span style="font-size:20px; font-weight:bold">Game State Management (Phone) Sample</span></p>
<p>This sample shows how to manage the transitions between different menus and gameplay states on Windows Phone.</p>
<p>&nbsp;</p>
<table border="0" style="margin-left:auto; margin-right:auto">
<tbody>
<tr>
<td><img src="description/XNA_GameState_01_small.JPG" alt="" width="160" height="90"></td>
<td><img src="description/phonegsm0.png" alt="" width="90" height="160"><br>
<br>
</td>
</tr>
</tbody>
</table>
<p><span style="font-size:20px; font-weight:bold">Sample Overview</span></p>
<div class="hxnx1" id="ID2EK">
<p>The sample implements a simple game flow with a <strong>Main</strong> menu, an
<strong>Options</strong> screen, some actual gameplay, and a <strong>Pause</strong> menu. It displays a loading screen in between the menus and gameplay, and uses a popup message box to confirm whether the user really wants to quit.</p>
<p>The <strong>ScreenManager</strong> class is a reusable component that maintains a stack of one or more
<strong>GameScreen</strong> instances. It coordinates the transitions from one screen to another, and takes care of routing user input to whatever screen is on top of the stack.</p>
<p>Each screen class (including the actual gameplay, which is just another screen) derives from
<strong>GameScreen</strong>. This provides <strong>Update</strong>, <strong>HandleInput</strong>, and
<strong>Draw</strong> methods, plus some logic for managing the transition state.
<strong>GameScreen</strong> does not actually implement any transition rendering effects, however. It merely provides information such as &quot;You are currently 30% of the way through transitioning off,&quot; leaving it up to the derived screen classes to do something
 sensible with that information in their drawing code. This makes it easy for screens to implement different visual effects on top of the same underlying transition infrastructure.</p>
The Windows Phone version of this sample comes with a number of improvements to take into account special considerations for working with the device.
<strong>InputState</strong> now contains fields for touch input. <strong>ScreenManager</strong> now supports
<strong>Gestures</strong> and handles serialiazation and deserialization of game screens to account for exiting of the game through the user or the device.
<strong>GameScreen</strong> also has <strong>Serialize</strong> and <strong>Deserialize</strong> methods that allow the subclasses to hook into the
<strong>ScreenManager</strong> serialization system.
<h2 class="subHeading">Sample Controls</h2>
<div class="hxnx2" id="ID2EXB">
<p>This sample uses the following keyboard and gamepad controls.</p>
</div>
</div>
<p>&nbsp;</p>
<table border="0" style="border:1px solid #d5d5d3">
<tbody>
<tr>
<th align="left" style="background-color:#efeff7">Action</th>
<th align="left" style="background-color:#efeff7">Windows Phone</th>
<th align="left" style="background-color:#efeff7">Windows - Keyboard Control</th>
<th align="left" style="background-color:#efeff7">Windows/Xbox - Gamepad Control</th>
</tr>
<tr>
<td>Select a menu entry.</td>
<td><strong>TAP</strong></td>
<td>UP ARROW, DOWN ARROW</td>
<td>Left thumb stick, D-Pad up and down</td>
</tr>
<tr>
<td>Accept the menu selection.</td>
<td><strong>TAP</strong></td>
<td>SPACEBAR, ENTER</td>
<td><strong>A</strong>, <strong>START</strong></td>
</tr>
<tr>
<td>Cancel the menu.</td>
<td><strong>BACK</strong></td>
<td>ESC</td>
<td><strong>B</strong>, <strong>BACK</strong></td>
</tr>
<tr>
<td>Move a game entity.</td>
<td>N/A</td>
<td>UP ARROW, DOWN ARROW, LEFT ARROW, and RIGHT ARROW</td>
<td>Left thumb stick</td>
</tr>
<tr>
<td>Pause the game.</td>
<td>N/A</td>
<td>ESC</td>
<td><strong>START</strong>, <strong>BACK</strong></td>
</tr>
</tbody>
</table>
<p id="mainBody">&nbsp;</p>
<h1 class="heading">How the Sample Works</h1>
<div class="hxnx1" id="ID2EHE">
<p>The source files in the <strong>ScreenManager</strong> folder (ScreenManager.cs, GameScreen.cs, and InputState.cs) provide a reusable state management component that could be used by any game. The files in the Screens folder implement the specific screens
 used by this sample: you would probably want to change or replace these to re-skin the menu system before using it in a game of your own.</p>
<p>Several different things can happen when one screen is stacked over the top of another:</p>
<ul>
<li>If the topmost screen is flagged as being a popup, it is drawn over the top of the screen below it. This is used for the &quot;Are you sure you want to quit?&quot; message boxes, and for the pause menu that is displayed over the top of the gameplay screen.
</li><li>If the topmost screen is not flagged as a popup, the screen below it automatically transitions off to get out of the way. This is used for the options screen, which is brought up over the top of the main menu. The main menu screen automatically transitions
 off while the options screen is active, and when the options screen exits, the main menu automatically transitions back on, without the options screen having to do anything specific to make this happen. This behavior is not really necessary for such a small
 sample, but comes in handy when building larger user interfaces with more complicated structures of nested menus.
</li><li>Because all the transition logic is implemented inside <strong>GameScreen.Update</strong>, specific screens can override this to achieve whatever custom stacking behaviors they want. For instance the
<strong>BackgroundScreen</strong> class, which sits behind all the different menu screens and is used to display a background image that will not be affected by menu transitions, overrides the
<strong>Update</strong> behavior to prevent itself transitioning off even though it has another screen on top of it.
</li></ul>
<p>The <strong>ScreenManager</strong> component does not directly update the screen transition states. It just calls
<strong>Update</strong> on each of the screens, telling them whether they are covered by some other non-popup screen, and whether some other screen on top of them has the input focus. The
<strong>GameScreen.Update</strong> method is responsible for updating the transition state in response to this information, transitioning on or off as appropriate.</p>
<p>The <strong>ScreenManager</strong> also calls <strong>GameScreen.HandleInput</strong> for the topmost active screen. Unlike the
<strong>Update</strong> method, this is only ever called for one screen per frame, because there should never be more than one screen responding to user input at the same time. Screens are considered to be active even while they are in the process of transitioning
 on. This lets players who are familiar with the game navigate quickly through the menus without having to bother waiting for transitions to complete. If they dismiss a menu before it has finished transitioning on, the transition will simply turn around and
 move back off again. You can see this in action if you toggle rapidly back and forth between the main menu and options screens.</p>
<p>Note that transitions are entirely optional. If a <strong>GameScreen</strong> leaves its
<strong>TransitionOnTime</strong> and <strong>TransitionOffTime</strong> properties set to zero, it will instantly pop on and off, and thus will have no need to implement transition effects in its rendering code.</p>
<p>The <strong>LoadingScreen</strong> coordinates transitions between the menu system and the game itself. Normally, one screen transitions off at the same time as the next screen is transitioning on. For larger transitions that can take a longer time to load
 their data we want the menu system to be entirely gone before we start loading the game. This is done as follows:</p>
<ul>
<li>Tell all the existing screens to transition off. </li><li>Activate a loading screen, which will transition on at the same time. </li><li>The loading screen monitors the state of the previous screens. </li><li>When it determines they have finished transitioning off, it activates the real next screen, which may take a long time to load its data. The loading screen will be the only thing displayed while this load is taking place.
</li></ul>
<p>New in 3.0: the <strong>GameScreen</strong> class, in conjunction with the <strong>
InputState</strong> helper, contains logic for tracking which gamepad is active. An Xbox can have up to four connected gamepads, so you should not always just assume the first controller is the active one. Players expect to be able to pick up any gamepad and
 use that to play the game. This behavior is implemented by the <strong>GameScreen.ControllingPlayer</strong> property, which is a
<strong>Nullable&lt;PlayerIndex&gt;</strong>. If this is null, any player can control the screen, but when it is set to a specific value, only that player has control. In this sample, the
<strong>MainMenuScreen</strong> responds to input from any controller. It works out which controller the player is using by noticing what controller was used to select each menu option. Whenever the main menu activates a different screen, it passes through
 this player index as the controlling player for the new screen. The controlling player selection is passed on from each screen to the next, so from this point on, only that player is able to control the game. Once gameplay is complete and the controlling player
 returns to the main menu, the controlling player is set back to null, so the sample will once more respond to input from any connected gamepad.</p>
<p>The <strong>GameplayScreen</strong> also includes logic to pause the game if the controlling player accidentally unplugs their gamepad.</p>
<p><span style="font-size:20px; font-weight:bold">Extending the Sample</span></p>
</div>
<div class="hxnx1" id="ID2EAH">
<p>You can extend the sample by adding new screens, changing the menu options, and altering the drawing code used by the
<strong>MenuScreen</strong>, <strong>MessageBoxScreen</strong>, and <strong>BackgroundScreen</strong> classes. For example, you could make the
<strong>MenuScreen</strong> transition effect slide vertically rather than horizontally, or add some subtle animation to the
<strong>BackgroundScreen</strong>.</p>
<p>In the interest of simplicity, this sample implements <strong>GameScreen</strong> as a standalone class rather than deriving from
<strong>DrawableGameComponent</strong>. If you want to use components together with this menu system, you could extend
<strong>GameScreen</strong> to host other components inside itself. Each screen would maintain a list of the components it is using, call
<strong>Initialize</strong> on new components when they are added, and plumb the <strong>
Update</strong> and <strong>Draw</strong> calls through to every component in this list.&nbsp;</p>
</div>
<p><br>
<br>
</p>

</div>


    </div>
</body>
</html>
